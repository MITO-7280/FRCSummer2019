// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc6394.csjissb.subsystem;


import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import com.ctre.phoenix.motorcontrol.can.VictorSPX;

import org.usfirst.frc6394.csjissb.Constants;
import org.usfirst.frc6394.csjissb.Robot;
import org.usfirst.frc6394.csjissb.RobotMap;
import org.usfirst.frc6394.csjissb.commands.Drive;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

public class Base extends Subsystem {

    TalonSRX leftMasterMotor = new TalonSRX(RobotMap.leftMasterMotor);
    TalonSRX leftSlaveMotor = new TalonSRX(RobotMap.leftSlaveMotor);
    TalonSRX rightMasterMotor = new TalonSRX(RobotMap.rightMasterMotor);
    TalonSRX rightSlaveMotor = new TalonSRX(RobotMap.rightSlaveMotor);

    RobotMap robotMap = new RobotMap();

    double leftSpeed;
    double rightSpeed;

    int targetDistanceX;
    int targetDistanceY;
    int targetDistanceZ;

    public boolean visionTurnOK = false;
    public boolean visionDriveOK = false;
    public boolean tableOn = false;


    public Base() {

        robotMap.TalonSRXInt(leftMasterMotor, Constants.kBasePeakOutput);
        robotMap.TalonSRXInt(rightMasterMotor, Constants.kBasePeakOutput);
        robotMap.TalonSRXInt(leftSlaveMotor, Constants.kBasePeakOutput);
        robotMap.TalonSRXInt(rightSlaveMotor,Constants.kBasePeakOutput);

        

        configVelocityPID();

        rightSlaveMotor.follow(rightMasterMotor);
        leftSlaveMotor.follow(leftSlaveMotor);

    }

    @Override
    public void initDefaultCommand() {

        setDefaultCommand(new Drive());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    public void drive(double twistValue, double throttleValue, double xValue){
        motorMode(NeutralMode.Coast);
        configVelocityPID();

        if (twistValue - throttleValue <= 0){
            leftSpeed = (twistValue - throttleValue - xValue) * Constants.kBaseSpeed;
            rightSpeed = (twistValue - throttleValue + xValue) * Constants.kBaseSpeed;
        } else {
            leftSpeed = (twistValue - throttleValue + xValue) * Constants.kBaseSpeed;
            rightSpeed = (twistValue - throttleValue - xValue) * Constants.kBaseSpeed;
        }
        if (leftSpeed <= 0){
            leftMasterMotor.setInverted(true);
            leftSlaveMotor.setInverted(true);
        } else {
            leftSpeed = - leftSpeed;
            leftMasterMotor.setInverted(false);
            leftSlaveMotor.setInverted(false);
        }
        if (rightSpeed <= 0){
            rightMasterMotor.setInverted(false);
            rightSlaveMotor.setInverted(false);
        } else {
            rightSpeed = - rightSpeed;
            rightMasterMotor.setInverted(true);
            rightSlaveMotor.setInverted(true);
        }

        
        speedDrive();

        showData();
    }
/*
    public double visionTurn() {
        tableOn = true;
        double zSpeed = 0;
        switch (Robot.netWorkTable.upTape){
            case 0: // can't find tape
                zSpeed = Robot.oi.motionStick.getZ();
                visionTurnOK = false;
                break;

            case 1: // the target is on the left
                zSpeed = -0.5;
                visionTurnOK = false;
                break;

            case 2: // the target is on the right
                zSpeed = 0.5;
                visionTurnOK = false;
                break;

            case 3: // the target is on the centre
                zSpeed = 0;
                visionTurnOK = true;
                break;
        }
        SmartDashboard.putNumber("visionTurn", zSpeed);
        SmartDashboard.putNumber("visionTurnCase", Robot.netWorkTable.upTape);

        return zSpeed;
    }

    public double[] visionDrive() {
        tableOn = true;
        double[] yxSpeed = {0,0};
        switch (Robot.netWorkTable.downTape) {
            case 0: // can't find tape
                yxSpeed[0] = Robot.oi.motionStick.getY();
                yxSpeed[1] = Robot.oi.motionStick.getX();
                visionDriveOK = false;
                break;
                
            case 1 | 4: // the target is on the left
                yxSpeed[0] = 0;
                yxSpeed[1] = 0.5;
                visionDriveOK = false;
                break;

            case 2 | 5: // the target is on the right
                yxSpeed[0] = 0;
                yxSpeed[1] = -0.5;
                visionDriveOK = false;
                break;

            case 3: // the target is on the centre
                yxSpeed[0] = Robot.oi.motionStick.getY(); // modified for further version
                yxSpeed[1] = 0;
                visionDriveOK = true;
                break;
        }
        SmartDashboard.putBoolean("visionDriveOK", visionDriveOK);
        SmartDashboard.putNumber("visionTurn", yxSpeed[1]);

        return yxSpeed;
    }

    public void speed(double zValue, double xValue){
        tableOn = false;
        double kfrontLeftSpeed = (zValue - xValue / 1.3) * Constants.kBaseSpeed;
        double krearLeftSpeed = (zValue - xValue / 1.3) * Constants.kBaseSpeed;
        double kfrontRightSpeed = (xValue + zValue / 1.3) * Constants.kBaseSpeed;
        double krearRighttSpeed = (zValue + xValue / 1.3) * Constants.kBaseSpeed;

        leftMasterMotor.set(ControlMode.Velocity, kfrontLeftSpeed);
        leftSlaveMotor.set(ControlMode.Velocity, krearLeftSpeed);
        rightMasterMotor.set(ControlMode.Velocity, kfrontRightSpeed);
        rightSlaveMotor.set(ControlMode.Velocity, krearRighttSpeed);

        showData();
    }
*/    

    public void speedDrive(){
        leftMasterMotor.set(ControlMode.Velocity, leftSpeed);
        rightMasterMotor.set(ControlMode.Velocity, rightSpeed);
    //    leftSlaveMotor.set(ControlMode.Velocity, 1000);
    //    rightSlaveMotor.set(ControlMode.Velocity, 1000);
        showData();
    }

    public void moveY(int _distance){
        targetDistanceY = _distance;
        motorMode(NeutralMode.Brake);

        leftMasterMotor.set(ControlMode.Position, _distance);
        leftSlaveMotor.set(ControlMode.Position, _distance);
        rightMasterMotor.set(ControlMode.Position, _distance);
        rightSlaveMotor.set(ControlMode.Position, _distance);

        showData();
    }

    public void TurnLeft(int _distance){
        targetDistanceX = _distance;
        motorMode(NeutralMode.Brake);

        leftMasterMotor.set(ControlMode.Position, _distance);
        leftSlaveMotor.set(ControlMode.Position, _distance);
        rightMasterMotor.set(ControlMode.Position, _distance);
        rightSlaveMotor.set(ControlMode.Position, _distance);

        showData();
    }

    public void turn180(){
        leftMasterMotor.set(ControlMode.Position, Constants.turn180);
        rightMasterMotor.set(ControlMode.Position, Constants.turn180);

        configPositionPID();
    }

    public void TurnRight(int _distance){
        targetDistanceX = _distance;
        motorMode(NeutralMode.Brake);

        leftMasterMotor.set(ControlMode.Position, _distance);
        leftSlaveMotor.set(ControlMode.Position, _distance);
        rightMasterMotor.set(ControlMode.Position, _distance);
        rightSlaveMotor.set(ControlMode.Position, _distance);

        showData();
    }

    // turn the robot, 363unit/degree
    /*public void turnZ(int _distance){
        targetDistanceZ = _distance;
        motorMode(NeutralMode.Brake);
        leftFrontMotor.set(ControlMode.Position, -_distance);
        leftRearMotor.set(ControlMode.Position, -_distance);
        rightFrontMotor.set(ControlMode.Position, _distance);
        rightRearMotor.set(ControlMode.Position, _distance);

        SmartDashboard.putNumber("LF position", leftFrontMotor.getSelectedSensorPosition());
        SmartDashboard.putNumber("LR position", leftRearMotor.getSelectedSensorPosition());
        SmartDashboard.putNumber("RF position", rightFrontMotor.getSelectedSensorPosition());
        SmartDashboard.putNumber("RR position", rightRearMotor.getSelectedSensorPosition());
    }*/

    public void percentageDrive(double _leftSpeed, double _rightSpeed){
        leftMasterMotor.set(ControlMode.PercentOutput, _leftSpeed);
        leftSlaveMotor.set(ControlMode.PercentOutput, _leftSpeed);
        rightMasterMotor.set(ControlMode.PercentOutput, _rightSpeed);
        rightSlaveMotor.set(ControlMode.PercentOutput, _rightSpeed);

        showData();

    }

    public int getCurrentDistance() {
        return rightMasterMotor.getSelectedSensorPosition();
    }

    //function that set the encoder position to zero
    public void zeroSensorPosition(){
        leftMasterMotor.setSelectedSensorPosition(0, Constants.kPIDLoopIdx, Constants.kTimeoutMs);
        leftSlaveMotor.setSelectedSensorPosition(0, Constants.kPIDLoopIdx, Constants.kTimeoutMs);
        rightMasterMotor.setSelectedSensorPosition(0, Constants.kPIDLoopIdx, Constants.kTimeoutMs);
        rightSlaveMotor.setSelectedSensorPosition(0, Constants.kPIDLoopIdx, Constants.kTimeoutMs);
    }

    public void stop(){
        motorMode(NeutralMode.Brake);

        drive(0,0,0);
    }

    private void motorMode(NeutralMode mode) {
        leftMasterMotor.setNeutralMode(mode);
        leftSlaveMotor.setNeutralMode(mode);
        rightMasterMotor.setNeutralMode(mode);
        rightSlaveMotor.setNeutralMode(mode);
    }

    public void configVelocityPID(){
        robotMap.setMotorPID(leftMasterMotor, 0.245, 0, 0, 0);
        robotMap.setMotorPID(leftSlaveMotor, 0.245, 0, 0, 0);
        robotMap.setMotorPID(rightMasterMotor, 0.197, 0.05, 0, 0);
        robotMap.setMotorPID(rightSlaveMotor, 0.197, 0.05, 0, 0);

        leftMasterMotor.configClosedLoopPeakOutput(0, 1);
        leftSlaveMotor.configClosedLoopPeakOutput(0, 1);
        rightMasterMotor.configClosedLoopPeakOutput(0, 1);
        rightSlaveMotor.configClosedLoopPeakOutput(0, 1);
    }

    public void configPositionPID(){
        robotMap.setMotorPID(leftMasterMotor, 0, 0.05, 0, 0.5);
        robotMap.setMotorPID(rightMasterMotor, 0, 0.1, 0, 1);

        leftMasterMotor.configClosedLoopPeakOutput(0, 0.5);
        leftSlaveMotor.configClosedLoopPeakOutput(0, 0.5);
        rightMasterMotor.configClosedLoopPeakOutput(0, 0.5);
        rightSlaveMotor.configClosedLoopPeakOutput(0, 0.5);
    }

    public void showData(){
        SmartDashboard.putNumber("L position", leftMasterMotor.getSelectedSensorPosition());
        SmartDashboard.putNumber("R position", rightMasterMotor.getSelectedSensorPosition());

        SmartDashboard.putNumber("L velocity", leftMasterMotor.getSelectedSensorVelocity());
        SmartDashboard.putNumber("R velocity", rightMasterMotor.getSelectedSensorVelocity());

        SmartDashboard.putNumber("left speed", leftSpeed);
        SmartDashboard.putNumber("right speed", rightSpeed);
        SmartDashboard.putNumber("percent output", leftMasterMotor.getMotorOutputPercent());
        SmartDashboard.putNumber("X value", Robot.oi.motionStick.getX());
        SmartDashboard.putNumber("Z value", Robot.oi.motionStick.getTwist() - Robot.oi.motionStick.getThrottle());
        SmartDashboard.getBoolean("left inverted", leftMasterMotor.getInverted());
        SmartDashboard.getBoolean("right inverted", rightMasterMotor.getInverted());
    }

}

